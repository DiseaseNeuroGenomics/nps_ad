---
title: "Analysis of NPS/AD"
subtitle: 'Loss of chrY'
author: "Developed by [Gabriel Hoffman](http://gabrielhoffman.github.io/)"
date: "Run on `r Sys.time()`"
documentclass: article
output: 
  html_document:
  toc: true
  smart: false
vignette: >
  %\VignetteIndexEntry{Decorrelate}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\usepackage[utf8]{inputenc}
---


<!--- 

cd /sc/arion/projects/CommonMind/hoffman/NPS-AD/work/nps_ad/
ml python
R

system("ml git; git pull")
rmarkdown::render('chrom_loss_analysis.Rmd');




# https://hoffmg01.u.hpc.mssm.edu/nps_ad/


# submit as job

DIR=`pwd`
echo '#!/bin/bash' > loss_of_Y.lsf 
echo "#BSUB -J loss_of_Y
#BSUB -P acc_CommonMind
#BSUB -q premium
#BSUB -n 36
#BSUB -R span[hosts=1]
#BSUB -W 12:00
#BSUB -o $DIR/loss_of_Y_%J.stdout
#BSUB -eo $DIR/loss_of_Y_%J.stderr
#BSUB -L /bin/bash

ml R/4.1.0-cairo libpng/16 python

R_LIBS_USER=/hpc/users/hoffmg01/.Rlib/R_410/
R_LIBS=$R_LIBS_USER:$R_LIBS

cd /hpc/users/hoffmg01/work/nps_ad

echo \"rmarkdown::render('loss_of_Y.Rmd')\" | R --vanilla
" >> loss_of_Y.lsf 

bsub < loss_of_Y.lsf

ml git
cd ~/build2/dreamlet
git pull
R CMD INSTALL .


--->

Examine distribution of chromosome loss events per cell 
  Is the probability of losing chrA related to loss of chrB after correcting for depth
  show overall loss rate per chromosome vs depth
  Is count per cell Poisson distributed?
  Use t-statistic as a proxy?


Donor level
  ashr within each cell type
  loss with age
  relate to phenotype



```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  warning=FALSE,
  message=FALSE,
  error = FALSE,
  tidy = FALSE,
  dev = c("png", "pdf"),
  package.startup.message = FALSE,
  cache = TRUE,
  cache.lazy = FALSE)
```

```{r load.packages, cache=FALSE}
library(tidyverse)
library(ggplot2)
library(cowplot)
library(lme4)
library(lmerTest)
library(SingleCellExperiment)
library(RNOmni)
```



```{r load.data}
# SingleCellExperiment 
datafile = "/sc/arion/projects/CommonMind/hoffman/NPS-AD/work/sceCombine_f1.RDS"
sceCombine = readRDS( datafile )

# OUTRIDER results
res_combine = readRDS("/sc/arion/projects/CommonMind/hoffman/NPS-AD/work/nps_ad/outliers.RDS")

# adjust p-value due to merging
res_combine$padjust = p.adjust(res_combine$pValue, "fdr")
res_combine$aberrant = res_combine$padjust < 0.05
```

```{r analysis}
# get unique information for each Channel
df_uniq = with(colData(sceCombine), unique(data.frame(Channel, SubID, dx, Sex, Age)))

# allow grouping by Channel, geneID, and celltype
# use data.table for faster merge
df_data = data.frame(sampleID = colnames(sceCombine), colData(sceCombine))

# total counts per chromosome
df_chr_counts = res_combine %>%
                group_by(geneID) %>%
                summarize(totalCounts = sum(rawcounts))

# combine outlier and sample data
df_res = left_join(res_combine, df_data, by="sampleID") %>%
  as_tibble %>% 
  mutate(Channel = gsub('-.*$','', sampleID),
         se = l2fc / zScore)  

# group and summarize
df_counts_aggr = df_res %>% 
  group_by(Channel, geneID, celltype) %>% 
  summarize(nAbb = sum(aberrant),
            nObs = length(aberrant),
            nAbb.up = sum(aberrant*(l2fc>1)),
            nAbb.down = sum(aberrant*(l2fc<1)),
            abber.rate.up = sum(aberrant*(l2fc>1)) / length(aberrant),
            abber.rate.down = sum(aberrant*(l2fc<1)) / length(aberrant) ) %>% 
  left_join(df_uniq, by="Channel") %>%
  left_join(df_chr_counts, by="geneID")
```


# Negative binomial model of aberrent counts
```{r aberrant.nb}
# only examine AD vs control
grid = expand.grid(geneID = sort(unique(df_counts_aggr$geneID)),
            celltype = sort(unique(df_counts_aggr$celltype)))

coefs = c('scale(Age)','dxAD')

# test outlier rate
###################

res_lm = lapply(1:nrow(grid), function(i){
  message("\r", i, "   ")

  idx = with(df_counts_aggr,  (dx %in% c("AD", "Control")) & (geneID==grid$geneID[i]) & (celltype==grid$celltype[i]))
  data = droplevels(df_counts_aggr[idx,])
  data$dx = factor(data$dx, c("Control", "AD"))

  if( sum(data$nAbb> 0) < 100){
    df = NULL
  }else{

    df1 = df2 = NULL

    if( sum(data$nAbb.down > 1) > 10){
      fit1 = glmer.nb(nAbb.down ~ offset(log(nObs)) + (1|SubID) + dx + scale(Age), data)
      df1 = data.frame( geneID = grid$geneID[i],
                  celltype = grid$celltype[i],
                  Direction="loss",
                  coef = coefs,
                  coef(summary(fit1))[coefs,,drop=FALSE])
    }

    if( sum(data$nAbb.up > 1) > 10){
      fit2 = glmer.nb(nAbb.up ~ offset(log(nObs)) + (1|SubID) + dx + scale(Age), data)

      
      df2 = data.frame( geneID = grid$geneID[i],
                  celltype = grid$celltype[i],
                  Direction="gain",
                  coef = coefs,
                  coef(summary(fit2))[coefs,,drop=FALSE])
    }

    df = rbind(df1, df2)
  }
  df
  })
res_lm = do.call(rbind, res_lm)

colnames(res_lm)[colnames(res_lm) == "Pr...z.."] = "pvalue"
res_lm$FDR = p.adjust(res_lm$pvalue, "fdr")
res_lm = res_lm[order(res_lm$FDR),]

res_lm$geneID = factor(res_lm$geneID, c(1:22, "X", "Y", "MT"))

ratio = with(res_lm, nlevels(celltype) / nlevels(geneID))

ggplot(res_lm[res_lm$coef=="dxAD",], aes(geneID, celltype, fill=z.value)) + geom_tile() + theme_classic() + theme(aspect.ratio=ratio) + scale_fill_gradient2(low = "blue", mid="white", high="red")
```



# chr21 trisomy is Down syndrome
# APP gene is on chr21

# Using z-score directly
```{r z.score}
grid = expand.grid(geneID = sort(unique(df_res$geneID)),
            celltype = sort(unique(df_res$celltype)))

coefs = c('dxAD', 'scale(Age)')

res_lmz = lapply(1:nrow(grid), function(i){
  cat("\r", i, "   ")

  idx = with(df_res, (dx %in% c("AD", "Control")) & (geneID==grid$geneID[i]) & (celltype==grid$celltype[i]))

  data = droplevels(df_res[idx,])
  data$dx = factor(data$dx, c("Control", "AD"))

  # test chromsome loss using pmin
  fit1 = lmer( RankNorm(pmin(zScore, 0)) ~ scale(log10(rawcounts+1)) + (1|batch) + (1|Channel) + (1|SubID) + dx + scale(Age), data = data)
  
  # test chromsome gain using pmax
  fit2 = lmer( RankNorm(pmax(zScore, 0)) ~ scale(log10(rawcounts+1)) + (1|batch) + (1|Channel) + (1|SubID) + dx + scale(Age), data = data)

  df1 = data.frame(chrom = grid$geneID[i], celltype = grid$celltype[i],
                    Direction="loss", coef = coefs,
                    coef(summary(fit1))[coefs,])

  df2 = data.frame(chrom = grid$geneID[i], celltype = grid$celltype[i],
                    Direction="gain", coef = coefs,
                    coef(summary(fit2))[coefs,])

  rbind(df1, df2)
})
res_lmz = do.call(rbind, res_lmz)

colnames(res_lmz)[colnames(res_lmz) == "Pr...t.."] = "pvalue"
res_lmz$FDR = p.adjust(res_lmz$pvalue, "fdr")
res_lmz = res_lmz[order(res_lmz$FDR),]

res_lmz$geneID = factor(res_lmz$chrom, c(1:22, "X", "Y", "MT"))

ratio = with(res_lmz, nlevels(celltype) / nlevels(geneID))

ggplot(res_lmz[res_lmz$coef=="dxAD",], aes(geneID, celltype, fill=z.value)) + geom_tile() + theme_classic() + theme(aspect.ratio=ratio) + scale_fill_gradient2(low = "blue", mid="white", high="red")
```



```{r test, eval=FALSE}
# fit = glmer(nAbb ~ offset(log(nObs)) + (1|Channel) + (1|SubID) + (1|geneID) + (1|celltype) + scale(log(totalCounts)) + dx, df_counts_aggr[df_counts_aggr$dx %in% c("AD", "Control"),], family="poisson")

# calcVarPart(fit)
# summary(fit)
```


# Predict AD
```{r predict.AD}
grid = expand.grid(geneID = sort(unique(df_res$geneID)),
            celltype = sort(unique(df_res$celltype)))

res_pred = lapply(1:nrow(grid), function(i){
  cat("\r", i, "   ")

  idx = with(df_res, (dx %in% c("AD", "Control")) & (geneID==grid$geneID[i]) & (celltype==grid$celltype[i]))

  data = droplevels(df_res[idx,])
  data$dx = factor(data$dx, c("Control", "AD"))

  # predict at cell level
  fit = glm(dx ~ zScore + I(zScore^2) + Age + Sex, data, family="binomial")
  data$ad_pred = predict(fit, type="response")

  # collapse by subject
  data2 = data %>%
            group_by(SubID) %>%
            summarize(nAbb = sum(aberrant),
            nObs = length(aberrant),
            nAbb.up = sum(aberrant*(l2fc>1)),
            nAbb.down = sum(aberrant*(l2fc<1)),
            abber.rate.up = sum(aberrant*(l2fc>1)) / length(aberrant),
            abber.rate.down = sum(aberrant*(l2fc<1)) / length(aberrant),
            Age = Age[1],
            Sex = Sex[1],
            Institution = Institution[1],
            dx = dx[1],
            ad_pred_cells = sum(ad_pred > 0.9) / length(ad_pred) )

  # predict AD at Subject-level using number of AD cells
  # + abber.rate.down + abber.rate.up
  fit = glm(dx ~ RankNorm(ad_pred_cells) + Age + Sex, data2, family="binomial")

  # calcVarPart(fit)
  # summary(fit)

  data.frame(chrom = grid$geneID[i], celltype = grid$celltype[i],
    t(coef(summary(fit))['RankNorm(ad_pred_cells)',]))
})
res_pred = do.call(rbind, res_pred)
```






```{r exit, cache=FALSE}
knitr::knit_exit()
```
# END


```{r pi1, eval=FALSE}
library(qvalue)
library(ashr)
library(lmerTest)
library(data.table)
library(tidyverse)

# saveRDS(res, "/sc/arion/scratch/hoffmg01/res.RDS")
# saveRDS(ods, "/sc/arion/scratch/hoffmg01/ods.RDS")
# res = readRDS("/sc/arion/scratch/hoffmg01/res.RDS")
# ods = readRDS("/sc/arion/scratch/hoffmg01/ods.RDS")

pi1 = function(beta, se){
  if( length(beta) < 10) return(NA)
  # fit = ash(beta, se)
  fit = ash(beta/se, rep(1, length(se)))
  1 - get_pi0(fit)
}

# get unique information for each Channel
df_uniq = with(colData(sceCombine), unique(data.frame(Channel, SubID, dx, Sex, Age)))

# allow grouping by Channel, geneID, and celltype
# use data.table for faster merge
df_data = data.table(data.frame(sampleID = colnames(sceCombine), colData(sceCombine)))
setkey(df_data, sampleID)
setkey(res, sampleID)

# total counts per chromosome
df_chr_counts = res %>%
                group_by(geneID) %>%
                summarize(totalCounts = sum(rawcounts))

df_res = left_join(res, df_data, by="sampleID") %>%
  as_tibble %>% 
  mutate(Channel = gsub('-.*$','', sampleID),
         se = l2fc / zScore)  


# Get outliers for aggregated across groups
df_counts = df_res %>% 
  group_by(Channel, geneID, celltype) %>% 
  summarize(nAbb = sum(aberrant),
            nObs = length(aberrant),
            nAbb.up = sum(aberrant*(l2fc>1)),
            nAbb.down = sum(aberrant*(l2fc>1)),
            abber.rate.up = sum(aberrant*(l2fc>1)) / length(aberrant),
            abber.rate.down = sum(aberrant*(l2fc<1)) / length(aberrant) )


df_counts = merge(df_counts, df_uniq, by="Channel")

library(lme4)
# fit = glmer.nb(nAbb ~ offset(log(nObs)) + (1|SubID) + (1|celltype), df_counts[df_counts$geneID==2,])

df_vp = lapply(1:22, function(x){
  fit = glmer(nAbb ~ offset(log(nObs)) + (1|SubID) + (1|celltype) , df_counts[df_counts$geneID==x,], family="poisson")

  data.frame(chrom = x, t(calcVarPart(fit)))
})
df_vp = do.call(rbind, df_vp)



df_counts_aggr = df_res %>% 
  group_by(Channel, geneID, celltype) %>% 
  summarize(nAbb = sum(aberrant),
            nObs = length(aberrant),
            nAbb.up = sum(aberrant*(l2fc>1)),
            nAbb.down = sum(aberrant*(l2fc>1)),
            abber.rate.up = sum(aberrant*(l2fc>1)) / length(aberrant),
            abber.rate.down = sum(aberrant*(l2fc<1)) / length(aberrant) ) %>% 
  left_join(df_uniq, by="Channel") %>%
  left_join(df_chr_counts, by="geneID")


fit = glmer(nAbb ~ offset(log(nObs)) + (1|Channel) + (1|SubID) + (1|geneID) + (1|celltype) + scale(log(totalCounts)) + dx, df_counts_aggr[df_counts_aggr$dx %in% c("AD", "Control"),], family="poisson")

calcVarPart(fit)
summary(fit)

df_sub = df_counts_aggr[df_counts_aggr$dx %in% c("AD", "Control"),]

grid = expand.grid(geneID = sort(unique(df_sub$geneID)),
            celltype = sort(unique(df_sub$celltype)))

# test outlier rate
###################
# note: outliers only called in Males
rm(res_lm)
res_lm = mclapply(1:nrow(grid), function(i){
  cat("\r", i, "   ")

  idx = with(df_sub, (geneID==grid$geneID[i]) & (celltype==grid$celltype[i]))
  data = droplevels(df_sub[idx,])
  data$dx = factor(data$dx, c("Control", "AD"))

  if( sum(data$nAbb> 0) < 10){
    df = NULL
  }else{

    fit = glmer(nAbb ~ offset(log(nObs)) + (1|SubID) + dx + scale(Age)*dx, data, family="poisson")

    coefs = c('scale(Age)','dxAD', 'dxAD:scale(Age)')
    df = data.frame( geneID = grid$geneID[i],
                celltype = grid$celltype[i],
                coef = coefs,
                coef(summary(fit))[coefs,,drop=FALSE])
  }
  df
  }, mc.cores=12)
res_lm = do.call(rbind, res_lm)

colnames(res_lm)[colnames(res_lm) == "Pr...z.."] = "pvalue"
res_lm$FDR = p.adjust(res_lm$pvalue, "fdr")
res_lm = res_lm[order(res_lm$FDR),]

res_lm$geneID = factor(res_lm$geneID, c(1:22, "X", "Y", "MT"))

ratio = with(res_lm, nlevels(celltype) / nlevels(geneID))

fig = ggplot(res_lm[res_lm$coef=="scale(Age)",], aes(geneID, celltype, fill=z.value)) + geom_tile() + theme_classic() + theme(aspect.ratio=ratio) + scale_fill_gradient2(low = "blue", mid="white", high="red")

ggsave("test.png", fig)



# Using z-score directly
#########################


# chr21 trisomy is Down syndrome
# APP gene is on chr21

df_sub = df_res[df_res$dx %in% c("AD", "Control"),]

grid = expand.grid(geneID = sort(unique(df_sub$geneID)),
            celltype = sort(unique(df_sub$celltype)))

res_lm = lapply(1:nrow(grid), function(i){
  cat("\r", i, "   ")

  idx = with(df_res, (geneID==grid$geneID[i]) & (celltype==grid$celltype[i]))

  data = droplevels(df_res[idx,])
  data$dx = factor(data$dx, c("Control", "AD"))

  # test chromsome loss using pmin
  fit1 = lmer( pmin(zScore, 0) ~ scale(log10(rawcounts+1)) + (1|batch) + (1|Channel) + (1|SubID) + dx + scale(Age), data = data)
  
  # test chromsome gain using pmax
  fit2 = lmer( pmax(zScore, 0) ~ scale(log10(rawcounts+1)) + (1|batch) + (1|Channel) + (1|SubID) + dx + scale(Age), data = data)

  coefs = c('dxAD', 'scale(Age)')
  df1 = data.frame(chrom = grid$geneID[i], celltype = grid$celltype[i],
                    Direction="loss", coef = coefs,
                    coef(summary(fit1))[coefs,])

  df2 = data.frame(chrom = grid$geneID[i], celltype = grid$celltype[i],
                    Direction="gain", coef = coefs,
                    coef(summary(fit2))[coefs,])

  rbind(df1, df2)
})
res_lm = do.call(rbind, res_lm)

colnames(res_lm)[colnames(res_lm) == "Pr...t.."] = "pvalue"
res_lm$FDR = p.adjust(res_lm$pvalue, "fdr")
res_lm = res_lm[order(res_lm$FDR),]

res_lm$geneID = factor(res_lm$chrom, c(1:22, "X", "Y", "MT"))

ratio = with(res_lm, nlevels(celltype) / nlevels(geneID))

fig = ggplot(res_lm[res_lm$coef=="scale(Age)",], aes(geneID, celltype, fill=z.value)) + geom_tile() + theme_classic() + theme(aspect.ratio=ratio) + scale_fill_gradient2(low = "blue", mid="white", high="red")

ggsave("test.png", fig)












# Using z-score directly
# lm() uses too much memory
# test AD-control directly
idx = with(df_res, (geneID=="21") & (dx %in% c('AD', 'Control')) & (celltype=='Glutamatergic neuron'))
df_sub = df_res[idx,]
df_sub = droplevels(df_sub)
df_sub$dx = factor(df_sub$dx, c("Control", "AD"))
fit = lmer( pmax(zScore, 0) ~ scale(rawcounts) + (1|Channel) + (1|SubID) + scale(Age) + dx, data = df_sub)

summary(fit)




df_ad = lapply( sort(unique(df_res$geneID)), function(chrom){
  df_sub = df_res[(df_res$geneID=="Y") &(df_res$dx %in% c('AD', 'Control')),]
  df_sub = droplevels(df_sub)

  # test chromsome loss using pmin
  fit1 = lmer( pmin(zScore, 0) ~ scale(log10(rawcounts+1)) + (1|celltype) + (1|Channel) + (1|SubID) + as.numeric(dx), data = df_sub)
  
  # test chromsome gain using pmax
  fit2 = lmer( pmax(zScore, 0) ~ scale(log10(rawcounts+1)) + (1|celltype) + (1|Channel) + (1|SubID) + as.numeric(dx), data = df_sub)

  rbind(data.frame(chrom = chrom, Direction="loss", t(coef(summary(fit1))['as.numeric(dx)',])),
        data.frame(chrom = chrom, Direction="gain", t(coef(summary(fit2))['as.numeric(dx)',])))
})
df_ad = do.call(rbind, df_ad)





# pi1 = 1 - qvalue(pValue)$pi0
df_pi1 = df_res %>% 
  group_by(Channel, geneID, celltype) %>% 
  summarize( pi1.ash = pi1(l2fc, se))


idx = with(df_res, which(Channel == "H1004_1" & geneID == "10"))

with(df_res[idx,], pi1(l2fc, se))
```



# need to exclude replicates




# or should I use a negative binomial model directly and the produce residauls.
```{r results}
head(results(ods))

nrow(results(ods,all=TRUE))

table(results(ods,all=TRUE)$padjust < 0.05)
```


fit = MGLMreg(cbind(y1, y2, y3, y4) ~ 1, data=ydata, dist='DM')

fit@coefficients / fit@SE














