---
title: "CCA network analysis of NPS/AD"
subtitle: 'CCA networks with decorrelate'
author: "Developed by [Gabriel Hoffman](http://gabrielhoffman.github.io/)"
date: "Run on `r Sys.time()`"
documentclass: article
output: 
  html_document:
  toc: true
  smart: false
vignette: >
  %\VignetteIndexEntry{Decorrelate}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\usepackage[utf8]{inputenc}
---


<!--- 

cd /hpc/users/hoffmg01/work/nps_ad
ml python
R
# rm -rf analysis_1_cache/

system("ml git; git pull")
rmarkdown::render("cca_networks.Rmd");


# https://hoffmg01.u.hpc.mssm.edu/nps_ad/





--->



```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  warning=FALSE,
  message=FALSE,
  error = FALSE,
  tidy = FALSE,
  dev = c("png", "pdf"),
  cache = TRUE,
  cache.lazy = FALSE)
```

```{r load.packages, cache=FALSE}
# Use cache=FALSE so that package are fully loaded each time
# This ensures that forks within mclapply() have these loaded
# Othewise, mclapply() not have access to these libraries and will fail 
#   unless the libraries are manually loaded within each fork
suppressPackageStartupMessages({
library(SingleCellExperiment)
library(dreamlet)
library(variancePartition)
})
```




```{r load.data}
# read pseudobulk
pbObj = readRDS("/sc/arion/projects/CommonMind/hoffman/NPS-AD/work/pbObj.RDS")

# read dreamlet fit
fit.dl = readRDS("/sc/arion/projects/CommonMind/hoffman/NPS-AD/work/fit.dl.RDS")

# compute residuals and average replicates

residList = lapply(fit.dl, function(fit){

  # get residuals
  res = residuals(fit)

  # extract metadata for these samples
  md = metadata(pbObj)[[1]]
  ids = intersect(colnames(res), md$sample_id)
  df = md[match(ids, md$sample_id),]
  df$group_id = droplevels(df$group_id)

  # Compute mean for each donor
  resAgg = lapply( levels(df$group_id), function(gid){

    idx = which(gid == df$group_id)

    rowMeans(res[,idx,drop=FALSE])
  })
  resAgg = do.call(cbind, resAgg)
  colnames(resAgg) = levels(df$group_id)

  resAgg
  })
names(residList) = names(fit.dl)
```



```{r cca.analysis.functions}

library(decorrelate)
library(RNOmni)
library(Rfast)

pairwise_cca = function(exprList){

  lvls = names(exprList)

  idx_combn = combn(length(lvls), 2)

  df = apply(idx_combn, 2, function(x){

    cat("\r", x, '   ')

    CT1 = names(exprList)[x[1]]
    CT2 = names(exprList)[x[2]]

    X = exprList[[CT1]]
    Y = exprList[[CT2]]

    ids = intersect(colnames(X), colnames(Y))

    if( length(ids) < 15){
      return(NULL)
    }

    X_sub = scale(t(X[,ids,drop=FALSE]))
    Y_sub = scale(t(Y[,ids,drop=FALSE]))

    incl = seq(1, 0.8*nrow(X_sub))   

    fit.cca = fastcca(X_sub[incl,],Y_sub[incl,])
    X.pred = X_sub[-incl,] %*% fit.cca$x.coef
    Y.pred = Y_sub[-incl,] %*% fit.cca$y.coef
    res.cor = cor.test(X.pred[,1], Y.pred[,1])
    se = sqrt((1-res.cor$estimate^2)/(nrow(X.pred)-2))

    data.frame(CT1 = CT1, CT2 = CT2, N = nrow(X_sub), lambda.x = fit.cca$lambdas[1],
      lambda.y = fit.cca$lambdas[2], rho = fit.cca$cramer.V, rho.emp = res.cor$estimate, se = se) 
  })
  df = do.call(rbind, df)

  df
}

dfToMatrix = function(df, V1, V2, value){

  lvls = unique(c(df[,V1], df[,V2]))
  C = diag(1, length(lvls))
  C[C!=1] = NA
  rownames(C) = lvls
  colnames(C) = lvls

  for(i in 1:nrow(df) ){
    C[df[,V1][i], df[,V2][i]] = df[[value]][i]
    C[df[,V2][i], df[,V1][i]] = df[[value]][i]
  }

  C
}
```

```{r cca.analysis}
df_cca = pairwise_cca( residList )

```

```{r plots}

C = dfToMatrix(df_cca, "CT1", "CT2", "rho.emp")

plotCorrMatrix(C)
```



```{r exit, cache=FALSE, eval=FALSE}
knitr::knit_exit()
```











