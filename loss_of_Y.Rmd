---
title: "Analysis of NPS/AD"
subtitle: 'Loss of chrY'
author: "Developed by [Gabriel Hoffman](http://gabrielhoffman.github.io/)"
date: "Run on `r Sys.time()`"
documentclass: article
output: 
  html_document:
  toc: true
  smart: false
vignette: >
  %\VignetteIndexEntry{Decorrelate}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\usepackage[utf8]{inputenc}
---


<!--- 

cd /hpc/users/hoffmg01/work/nps_ad
ml python
R

system("ml git; git pull")
rmarkdown::render("loss_of_Y.Rmd");


# https://hoffmg01.u.hpc.mssm.edu/nps_ad/


ml git
cd ~/build2/dreamlet
git pull
R CMD INSTALL .


--->



```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  warning=FALSE,
  message=FALSE,
  error = FALSE,
  tidy = FALSE,
  dev = c("png", "pdf"),
  package.startup.message = FALSE,
  cache = TRUE,
  cache.lazy = FALSE)
```

```{r load.packages, cache=FALSE}
# Use cache=FALSE so that package are fully loaded each time
# This ensures that forks within mclapply() have these loaded
# Othewise, mclapply() not have access to these libraries and will fail 
#   unless the libraries are manually loaded within each fork
library(SingleCellExperiment)
library(zellkonverter)
library(DelayedArray)
library(HDF5Array)
library(dreamlet)
library(muscat)
library(cowplot)
library(zenith)
library(scater)
library(data.table)
library(S4Vectors)
library(tidyverse)
library(kableExtra)
library(qvalue)
library(corrplot)
library(GSEABase)
library(GenomicRanges)

vsn = packageVersion("zellkonverter")
if( compareVersion(as.character(vsn), "1.3.3") == -1){
  stop("zellkonverter version must be >=1.3.3  Currently: ", as.character(vsn))
}
```




```{r load.data, cache=FALSE}
datafile = "/sc/arion/projects/CommonMind/hoffman/NPS-AD/work/sceCombine_f1.RDS"

sceCombine = readRDS( datafile )
```

```{r par}
library(stringr)
library(AnnotationHub)
ah = AnnotationHub()

# Get ENSEMBL v104
res = query(ah,"EnsDb.Hsapiens.v104")
ann = ah[[res$ah_id]]

# get GRanges of gene locations 
# all genes:  keys(ann)
res = select(ann, keys = rownames(sceCombine), columns = c('SEQNAME', 'GENESEQSTART', 'GENESEQEND'))
gr = with(res, GRanges(SEQNAME, IRanges(GENESEQSTART, GENESEQEND, name=GENEID)))

# https://useast.ensembl.org/info/genome/genebuild/human_PARS.html
# chromosome:GRCh38:Y:1 - 10000 is unique to Y but is a string of 10000 Ns
# chromosome:GRCh38:Y:10001 - 2781479 is shared with X: 10001 - 2781479 (PAR1)
# chromosome:GRCh38:Y:2781480 - 56887902 is unique to Y
# chromosome:GRCh38:Y:56887903 - 57217415 is shared with X: 155701383 - 156030895 (PAR2)
# chromosome:GRCh38:Y:57217416 - 57227415 is unique to Y

regions = c(Ypar = 'Y:1-10000',
  Ypar = 'Y:10001-2781479', # shared with X: 10001 - 2781479 (PAR1)
  # Ypar = 'Y:2781480-56887902', # unique to Y
  Ypar = 'Y:56887903-57217415', # shared with X: 155701383 - 156030895 (PAR2)
  # Ypar = 'Y:57217416-57227415', # unique to Y
  PAR1 = 'X:10001-2781479',
  PAR2 = 'X:155701383-156030895')

df_regions = str_split(regions, ':|-', simplify=TRUE)
df_regions = data.frame(df_regions, SEQ=names(regions))
gr_par = with(df_regions, GRanges(X1, IRanges(as.numeric(X2), as.numeric(X3), name=SEQ)))

idx = which(gr %within% gr_par[names(gr_par) == "Ypar"])

# genes from chrY to exclude due to overlap with PAR
idx = which(gr[seqnames(gr) == 'Y'] %over% gr_par[names(gr_par) == "Ypar"])
gr[seqnames(gr) == 'Y'][idx]
```

# Check ploidy
```{r ploidy}
library(SingleCellExperiment)
library(DelayedMatrixStats)

# sum reads across chromosome to identify chromsome loss
chroms = levels(rowData(sceCombine)$gene_chrom)
chromExpr = lapply( rev(chroms), function(chrom, sce){

  message("\r", chrom, "    ")

  # genes on specified chromsome
  genes = rownames(rowData(sce))[rowData(sce)$gene_chrom == chrom]

  # sum reads across genes on this chromosome
  chromCounts = colSums2(assay(sce, 'X'), rows=genes)

  df = data.frame(t(chromCounts), check.names=FALSE)
  rownames(df) = chrom
  colnames(df) = colnames(sce)

  df
  }, sce=sceCombine)
chromExpr = do.call(rbind, chromExpr)
```


```{r outrider}
library(OUTRIDER)
ods <- OutriderDataSet(countData=chromExpr)

# ods <- OUTRIDER(ods, q=2, implementation="pca")

# Withoutout autoencoder
ods = OUTRIDER::fit(ods)

# or should I use a negative binomial model directly and the produce residauls.

head(results(ods))

nrow(results(odsa,all=TRUE))

table(results(ods)$padjust < 0.05)
```






