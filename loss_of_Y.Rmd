---
title: "Analysis of NPS/AD"
subtitle: 'Loss of chrY'
author: "Developed by [Gabriel Hoffman](http://gabrielhoffman.github.io/)"
date: "Run on `r Sys.time()`"
documentclass: article
output: 
  html_document:
  toc: true
  smart: false
vignette: >
  %\VignetteIndexEntry{Decorrelate}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\usepackage[utf8]{inputenc}
---


<!--- 

cd /hpc/users/hoffmg01/work/nps_ad
ml python
R

system("ml git; git pull")
rmarkdown::render("loss_of_Y.Rmd");


# https://hoffmg01.u.hpc.mssm.edu/nps_ad/


ml git
cd ~/build2/dreamlet
git pull
R CMD INSTALL .


--->



```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  warning=FALSE,
  message=FALSE,
  error = FALSE,
  tidy = FALSE,
  dev = c("png", "pdf"),
  package.startup.message = FALSE,
  cache = TRUE,
  cache.lazy = FALSE)
```

```{r load.packages, cache=FALSE}
# Use cache=FALSE so that package are fully loaded each time
# This ensures that forks within mclapply() have these loaded
# Othewise, mclapply() not have access to these libraries and will fail 
#   unless the libraries are manually loaded within each fork
library(SingleCellExperiment)
library(zellkonverter)
library(DelayedArray)
library(DelayedMatrixStats)
library(HDF5Array)
library(dreamlet)
library(scater)
library(kableExtra)
library(GenomicRanges)
```




```{r load.data, cache=FALSE}
datafile = "/sc/arion/projects/CommonMind/hoffman/NPS-AD/work/sceCombine_f1.RDS"

sceCombine = readRDS( datafile )
```

```{r par}
library(stringr)
library(AnnotationHub)
ah = AnnotationHub()

# Get ENSEMBL v104
res = query(ah,"EnsDb.Hsapiens.v104")
ann = ah[[res$ah_id]]

# get GRanges of gene locations 
# all genes:  keys(ann)
res = select(ann, keys = rownames(sceCombine), columns = c('SEQNAME', 'GENESEQSTART', 'GENESEQEND'))
gr = with(res, GRanges(SEQNAME, IRanges(GENESEQSTART, GENESEQEND, name=GENEID)))

# https://useast.ensembl.org/info/genome/genebuild/human_PARS.html
# chromosome:GRCh38:Y:1 - 10000 is unique to Y but is a string of 10000 Ns
# chromosome:GRCh38:Y:10001 - 2781479 is shared with X: 10001 - 2781479 (PAR1)
# chromosome:GRCh38:Y:2781480 - 56887902 is unique to Y
# chromosome:GRCh38:Y:56887903 - 57217415 is shared with X: 155701383 - 156030895 (PAR2)
# chromosome:GRCh38:Y:57217416 - 57227415 is unique to Y

regions = c(Ypar = 'Y:1-10000',
  Ypar = 'Y:10001-2781479', # shared with X: 10001 - 2781479 (PAR1)
  # Ypar = 'Y:2781480-56887902', # unique to Y
  Ypar = 'Y:56887903-57217415', # shared with X: 155701383 - 156030895 (PAR2)
  # Ypar = 'Y:57217416-57227415', # unique to Y
  PAR1 = 'X:10001-2781479',
  PAR2 = 'X:155701383-156030895')

df_regions = str_split(regions, ':|-', simplify=TRUE)
df_regions = data.frame(df_regions, SEQ=names(regions))
gr_par = with(df_regions, GRanges(X1, IRanges(as.numeric(X2), as.numeric(X3), name=SEQ)))

idx = which(gr %within% gr_par[names(gr_par) == "Ypar"])

# genes from chrY to exclude due to overlap with PAR
idx = which(gr[seqnames(gr) == 'Y'] %over% gr_par[names(gr_par) == "Ypar"])
gr[seqnames(gr) == 'Y'][idx]
```


# Check ploidy
```{r ploidy}
#' Sum counts across chromosome
#'
#' Sum counts across chromosome
#'
#' @param sce SingleCellExperiment
#' @param assay which assay to summarize
#' @param geneInfo \code{data.frame} storing gene ids and chromosome
#' @param chromCol name of column in \code{geneInfo} storing chromosome
#' @param geneCol name of column in \code{geneInfo} storing gene
#'
#' @import SingleCellExperiment
#' @importFrom DelayedMatrixStats colSums2 
countsByChrom = function(sce, assay, geneInfo, chromCol, geneCol, BPPARAM=SerialParam()){

  if( ! chromCol %in% colnames(geneInfo) ){
    stop("geneInfo must have column ", chromCol)
  }
  if( ! geneCol %in% colnames(geneInfo) ){
    stop("geneInfo must have column ", geneCol)
  }
   if( ! assay %in% assayNames(sceCombine) ){
    stop("assay not found in SingleCellExperiment: ", assay)
  }

  # unique set of chroms
  chroms = as.character(sort(unique(geneInfo[[chromCol]])))

  # for each chromosome
  chromExpr = bplapply( chroms, function(chrom, counts){

    suppressPackageStartupMessages({
    library(DelayedArray)
    library(HDF5Array)
    library(DelayedMatrixStats)
    })

    # genes on specified chromsome
    genes = geneInfo[[geneCol]][geneInfo[[chromCol]] == chrom]

    message("\r", chrom, ": ", length(genes), '     ')

    # sum reads across genes on this chromosome
    # this function call avoids overflow
    chromCounts = colSums2(counts[genes,])

    # return as data.frame
    df = data.frame(t(chromCounts), check.names=FALSE)
    rownames(df) = chrom
    colnames(df) = colnames(sce)

    df
    }, counts = assay(sce, assay), BPPARAM=BPPARAM)
  chromExpr = do.call(rbind, chromExpr)

  chromExpr
}

chromExpr = countsByChrom(sceCombine, 'X', rowData(sceCombine), 'gene_chrom', 'gene_id', BPPARAM=SnowParam(6, progressbar=TRUE))
```


# # Check ploidy
# ```{r ploidy}
# #' Sum counts across chromosome
# #'
# #' Sum counts across chromosome
# #'
# #' @param sce SingleCellExperiment
# #' @param assay which assay to summarize
# #' @param geneInfo \code{data.frame} storing gene ids and chromosome
# #' @param chromCol name of column in \code{geneInfo} storing chromosome
# #' @param geneCol name of column in \code{geneInfo} storing gene
# #'
# #' @import SingleCellExperiment
# #' @importFrom DelayedMatrixStats colSums2 
# countsByChrom = function(sce, assay, geneInfo, chromCol, geneCol){

#   if( ! chromCol %in% colnames(geneInfo) ){
#     stop("geneInfo must have column ", chromCol)
#   }
#   if( ! geneCol %in% colnames(geneInfo) ){
#     stop("geneInfo must have column ", geneCol)
#   }
#    if( ! assay %in% assayNames(sceCombine) ){
#     stop("assay not found in SingleCellExperiment: ", assay)
#   }

#   # unique set of chroms
#   chroms = sort(unique(geneInfo[[chromCol]]))

#   # for each chromosome
#   chromExpr = lapply( chroms, function(chrom){

#     message("\r", chrom, "    ")

#     # genes on specified chromsome
#     genes = geneInfo[[geneCol]][geneInfo[[chromCol]] == chrom]

#     # sum reads across genes on this chromosome
#     # this function call avoids overflow
#     chromCounts = colSums2(assay(sce, assay)[genes,])

#     # return as data.frame
#     df = data.frame(t(chromCounts), check.names=FALSE)
#     rownames(df) = chrom
#     colnames(df) = colnames(sce)

#     df
#     })
#   chromExpr = do.call(rbind, chromExpr)

#   chromExpr
# }

# chromExpr = countsByChrom(sceCombine, 'X', rowData(sceCombine), 'gene_chrom', 'gene_id')
# ```


```{r outrider}
library(OUTRIDER)
ods <- OutriderDataSet(countData=chromExpr)

# ods <- OUTRIDER(ods, q=2, implementation="pca")

# Withoutout autoencoder
ods = estimateSizeFactors(ods)
# ods = OUTRIDER::controlForConfounders(ods, q=2)
ods = OUTRIDER::fit(ods)
ods = OUTRIDER::computePvalues(ods, alternative="less", method="BH")
# ods = OUTRIDER::computeZscores(ods, FALSE)

plotQQ(ods, geneID='feature_1')
plotQQ(ods, global=TRUE)


plotVolcano(ods, "Y", basePlot=TRUE)

plotExpressionRank(ods, "Y", basePlot=TRUE)

plotExpectedVsObservedCounts(ods, "Y", basePlot=TRUE)

plotPowerAnalysis(ods) + theme_classic() + theme(aspect.ratio=1)


# need to exclude replicates




# or should I use a negative binomial model directly and the produce residauls.

head(results(ods))

nrow(results(odsa,all=TRUE))

table(results(ods)$padjust < 0.05)
```






