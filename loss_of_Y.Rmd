---
title: "Analysis of NPS/AD"
subtitle: 'Loss of chrY'
author: "Developed by [Gabriel Hoffman](http://gabrielhoffman.github.io/)"
date: "Run on `r Sys.time()`"
documentclass: article
output: 
  html_document:
  toc: true
  smart: false
vignette: >
  %\VignetteIndexEntry{Decorrelate}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\usepackage[utf8]{inputenc}
---


<!--- 

cd /hpc/users/hoffmg01/work/nps_ad
ml python
R

system("ml git; git pull")
rmarkdown::render('loss_of_Y.Rmd');


# https://hoffmg01.u.hpc.mssm.edu/nps_ad/


# submit as job

DIR=`pwd`
echo '#!/bin/bash' > loss_of_Y.lsf 
echo "#BSUB -J loss_of_Y
#BSUB -P acc_CommonMind
#BSUB -q premium
#BSUB -n 36
#BSUB -R span[hosts=1]
#BSUB -W 12:00
#BSUB -o $DIR/loss_of_Y_%J.stdout
#BSUB -eo $DIR/loss_of_Y_%J.stderr
#BSUB -L /bin/bash

ml R/4.1.0-cairo libpng/16 python

R_LIBS_USER=/hpc/users/hoffmg01/.Rlib/R_410/
R_LIBS=$R_LIBS_USER:$R_LIBS

cd /hpc/users/hoffmg01/work/nps_ad

echo \"rmarkdown::render('loss_of_Y.Rmd')\" | R --vanilla
" >> loss_of_Y.lsf 

bsub < loss_of_Y.lsf

ml git
cd ~/build2/dreamlet
git pull
R CMD INSTALL .


--->



```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  warning=FALSE,
  message=FALSE,
  error = FALSE,
  tidy = FALSE,
  dev = c("png", "pdf"),
  package.startup.message = FALSE,
  cache = TRUE,
  cache.lazy = FALSE)
```

```{r load.packages, cache=FALSE}
# Use cache=FALSE so that package are fully loaded each time
# This ensures that forks within mclapply() have these loaded
# Othewise, mclapply() not have access to these libraries and will fail 
#   unless the libraries are manually loaded within each fork
library(SingleCellExperiment)
library(zellkonverter)
library(DelayedArray)
library(DelayedMatrixStats)
library(HDF5Array)
library(dreamlet)
library(scater)
library(cowplot)
library(kableExtra)
library(GenomicRanges)
```


```{r load.data, cache=FALSE}
datafile = "/sc/arion/projects/CommonMind/hoffman/NPS-AD/work/sceCombine_f1.RDS"

sceCombine = readRDS( datafile )
```

```{r par, eval=FALSE}
library(stringr)
library(AnnotationHub)
ah = AnnotationHub()

# Get ENSEMBL v104
res = query(ah,"EnsDb.Hsapiens.v104")
ann = ah[[res$ah_id]]

# get GRanges of gene locations 
# all genes:  keys(ann)
res = select(ann, keys = rownames(sceCombine), columns = c('SEQNAME', 'GENESEQSTART', 'GENESEQEND'))
gr = with(res, GRanges(SEQNAME, IRanges(GENESEQSTART, GENESEQEND, name=GENEID)))

# https://useast.ensembl.org/info/genome/genebuild/human_PARS.html
# chromosome:GRCh38:Y:1 - 10000 is unique to Y but is a string of 10000 Ns
# chromosome:GRCh38:Y:10001 - 2781479 is shared with X: 10001 - 2781479 (PAR1)
# chromosome:GRCh38:Y:2781480 - 56887902 is unique to Y
# chromosome:GRCh38:Y:56887903 - 57217415 is shared with X: 155701383 - 156030895 (PAR2)
# chromosome:GRCh38:Y:57217416 - 57227415 is unique to Y

regions = c(Ypar = 'Y:1-10000',
  Ypar = 'Y:10001-2781479', # shared with X: 10001 - 2781479 (PAR1)
  # Ypar = 'Y:2781480-56887902', # unique to Y
  Ypar = 'Y:56887903-57217415', # shared with X: 155701383 - 156030895 (PAR2)
  # Ypar = 'Y:57217416-57227415', # unique to Y
  PAR1 = 'X:10001-2781479',
  PAR2 = 'X:155701383-156030895')

df_regions = str_split(regions, ':|-', simplify=TRUE)
df_regions = data.frame(df_regions, SEQ=names(regions))
gr_par = with(df_regions, GRanges(X1, IRanges(as.numeric(X2), as.numeric(X3), name=SEQ)))

idx = which(gr %within% gr_par[names(gr_par) == "Ypar"])

# genes from chrY to exclude due to overlap with PAR
idx = which(gr[seqnames(gr) == 'Y'] %over% gr_par[names(gr_par) == "Ypar"])
gr[seqnames(gr) == 'Y'][idx]
```


# Check ploidy
```{r ploidy, eval=FALSE}
source("/hpc/users/hoffmg01/work/nps_ad/aggregateByFeatures.R")

chromExpr = aggregateByFeatures(sceCombine, 'X', rowData(sceCombine)$gene_chrom, rowData(sceCombine)$gene_id, BPPARAM=SnowParam(6, progressbar=TRUE))

saveRDS(chromExpr, "chromExpr.RDS")
```

```{r compute.ploidy}
chromExpr = rowsum(assay(sceCombine, "X"), rowData(sceCombine)$gene_chrom)
```


# OUTRIDER analysis
Only keep males, and only keep one replicate per Donor

```{r outrider}
library(OUTRIDER)
ods <- OutriderDataSet(countData=chromExpr[,sceCombine$Sex=="Male"])

# exclude technical replicates since they are not independent
keep = grep("_1", as.character(sceCombine$Channel[sceCombine$Sex=="Male"]))
sampleExclusionMask(ods) <- TRUE 
sampleExclusionMask(ods[,keep]) <- FALSE

ods <- filterExpression(ods, minCounts=TRUE, filterGenes=TRUE)

# standard call
# ods <- OUTRIDER(ods)

# Without autoencoder
ods = estimateSizeFactors(ods)
ods = controlForConfounders(ods, q=2, implementation="pca", BPPARAM=SnowParam(12, progressbar=TRUE))
ods = fit(ods, BPPARAM=SnowParam(12, progressbar=TRUE))
ods = computePvalues(ods, alternative="less", method="BH")
ods = computeZscores(ods)

# compute results
res = results(ods, all=TRUE)
```


library(qvalue)
library(ashr)


df_pi1 = res %>% 
  group_by(Individual + cell type) %>% 
  summarize( pi1 = 1 - qvalue(p)$pi0)


```{r rm}
rm("res", "chromExpr", "sceCombine")
gc()
```

is Y sufficiently expressed?

```{r plotExpressedGenes, eval=FALSE}
plotExpressedGenes(ods)
```


```{r plotAberrantPerSample}
plotAberrantPerSample(ods, padjCutoff=0.05) + theme_classic() + theme(aspect.ratio=1)
```

```{r plotQQ.Y, fig.width=5, fig.height=4}
plotQQ(ods, geneID='Y') + theme_classic() + theme(aspect.ratio=1)
plotQQ(ods, geneID='1') + theme_classic() + theme(aspect.ratio=1)
```

```{r plotQQ.global, fig.width=5, fig.height=4}
plotQQ(ods, global=TRUE) + theme_classic() + theme(aspect.ratio=1)
```


```{r plotVolcano, fig.width=8, fig.height=8, eval=FALSE}
plotVolcano(ods, "Y", basePlot=TRUE) + theme_classic() + theme(aspect.ratio=1)
plotVolcano(ods, "1", basePlot=TRUE) + theme_classic() + theme(aspect.ratio=1)
```

```{r plotExpressionRank, fig.width=8, fig.height=8, dev="png"}
for( x in rownames(ods) ){
  plotExpressionRank(ods, x, basePlot=TRUE) + theme_classic() + theme(aspect.ratio=1)
}
```

```{r plotExpectedVsObservedCounts, fig.width=50, fig.height=8, dev="png"}
figList = lapply(rownames(ods), function(x){
  plotExpectedVsObservedCounts(ods, x, basePlot=TRUE) + theme_classic() + theme(aspect.ratio=1)
})
plot_grid(plotlist=figList, ncol=4)
rm(figList); gc()
```


```{r plotPowerAnalysis, fig.width=5, fig.height=4}
plotPowerAnalysis(ods) + theme_classic() + theme(aspect.ratio=1)
```


# need to exclude replicates




# or should I use a negative binomial model directly and the produce residauls.
```{r results}
head(results(ods))

nrow(results(ods,all=TRUE))

table(results(ods,all=TRUE)$padjust < 0.05)
```


fit = MGLMreg(cbind(y1, y2, y3, y4) ~ 1, data=ydata, dist='DM')

fit@coefficients / fit@SE














